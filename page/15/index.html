<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>文KRIFE齐的博客 - 搭建中</title><meta name="author" content="文KRIFE齐"><meta name="copyright" content="文KRIFE齐"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="目前正处于搭建测试环节">
<meta property="og:type" content="website">
<meta property="og:title" content="文KRIFE齐的博客">
<meta property="og:url" content="http://example.com/page/15/index.html">
<meta property="og:site_name" content="文KRIFE齐的博客">
<meta property="og:description" content="目前正处于搭建测试环节">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:author" content="文KRIFE齐">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/page/15/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '文KRIFE齐的博客',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-07-01 22:20:12'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">834</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="文KRIFE齐的博客"><span class="site-name">文KRIFE齐的博客</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">文KRIFE齐的博客</h1></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/04/22/Unity%E5%B0%B1%E4%B8%9A%E8%B7%AF%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/UFW%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/UF%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E5%B0%8F%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/UFL9%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97/UFL9-3%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97%E7%9A%84%E8%8E%B7%E5%8F%96%E8%BE%93%E5%85%A5%E6%B6%88%E6%81%AF/" title="UFL9-3——输入控制模块的获取输入消息">UFL9-3——输入控制模块的获取输入消息</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-22T10:25:26.000Z" title="发表于 2024-04-22 18:25:26">2024-04-22</time></span></div><div class="content">UFL9-3——输入控制模块的获取输入消息
遗留问题：在真正制作改键功能时，我们应该如何获取到任意键盘或任意鼠标输入来记录对应的输入信息
实现获取输入信息逻辑
在InputManager​的更新函数中，获取当前输入内容，用委托返回给外部
主要思路：
当存在某个键按下输入时，遍历监听​​KeyCode​​枚举中所有键位，检测是哪个键位输入了
当没有监听到时，监听鼠标左中右键键位，检测是哪个键位输入了
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//是否开启了输入检测private bool isCheckInput;//用于在改键时获取输入信息的委托，只有当Update内获取到信息的时候 再通过委托传递出去private UnityAction&lt;InputInfo&gt; getInputInfoCallBack;private InputManager()&#123;    MonoManager.Instance.AddUpdateLis ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/04/22/Unity%E5%B0%B1%E4%B8%9A%E8%B7%AF%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/UFW%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/UF%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E5%B0%8F%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/UFL9%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97/UFL9-2%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97%E7%9A%84%E6%94%B9%E9%94%AE%E5%8A%9F%E8%83%BD/" title="UFL9-2——输入控制模块的改键功能">UFL9-2——输入控制模块的改键功能</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-22T10:25:09.000Z" title="发表于 2024-04-22 18:25:09">2024-04-22</time></span></div><div class="content">UFL9-2——输入控制模块的改键功能
分析改键功能需求

改键功能应该是针对某一个行为的
游戏中的行为是固定的，我们需要改变的是触发该行为的按键
比如：角色有技能1、技能2、技能3，我们改变的是触发这些行为的输入
具体键位的触发不应该写死，而是需要根据存储的键位数据进行初始化或进行修改
键位的修改可以是键盘输入，也可以是鼠标输入，输入类型也可以是任意的
比如：触发技能1，可以修改为键盘输入，也可以修改为鼠标输入
可以是按下、可以是抬起、也可以是长按，具体是哪种应该根据你的需求变化

根据需求整理思路并制作
输入管理器主要做的事情，根据输入的信息，触发对应的事件，其中输入信息可变，触发的事件也可变


改键功能应该是针对某一个行为的，触发的事件类型应该是针对行为的，因为行为一般在游戏中是固定的
因此，我们在事件中心触发的事件不应该再是某种操作类型，而是某种行为，
因此我们可以把原来的操作类型事件如：E_Mouse​ 等删除或者注释，转而声明各种行为的事件名
（热键事件诸如水平轴和垂直轴不能删除，因为它们的修改不是在管理器内实现的）
假设我们有三种事件需要去监听设备输入
 1234567 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/04/22/Unity%E5%B0%B1%E4%B8%9A%E8%B7%AF%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/UFW%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/UF%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E5%B0%8F%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/UFL9%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97/UFL9-1%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/" title="UFL9-1——输入控制模块的具体实现">UFL9-1——输入控制模块的具体实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-22T10:24:11.000Z" title="发表于 2024-04-22 18:24:11">2024-04-22</time></span></div><div class="content">UFL9-1——输入控制模块的具体实现
输入控制模块的基本原理（以键盘为例）


制作 InputManager​ 单例模式管理器
 1234public class InputManager : BaseManager&lt;InputManager&gt;&#123;    private InputManager() &#123; &#125;&#125;


在输入管理器中进行按键检测
要检测哪个按键，就在帧更新方法内监听对应的方法，帧更新方法需要在添加到公共Mono模块的帧更新内
 123456789101112131415161718private InputManager()&#123;    MonoManager.Instance.AddUpdateListener(InputUpdate);&#125;// 开启或者关闭输入模块管理的检测public void StartOrCloseInputManager(bool isCheckInput)&#123;    this.isCheckInput = isCheckInput;&#125;private void ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/04/22/Unity%E5%B0%B1%E4%B8%9A%E8%B7%AF%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/UFW%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/UF%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E5%B0%8F%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/UFL9%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97/" title="UFL9——输入控制模块">UFL9——输入控制模块</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-22T05:18:46.000Z" title="发表于 2024-04-22 13:18:46">2024-04-22</time></span></div><div class="content">UFL9——输入控制模块

前置知识点

Unity中 Input​ 公共类 相关知识点（Unity四部曲之Unity入门中）
事件中心模块


注意：

本节课主要针对的是PC端，鼠标键盘输入相关的内容，如果是手游，会有些不同，但是整体思路是一致的
本节课中主要针对老输入系统（Input​公共类）进行封装
新输入系统（InputSystem​）相关知识请观看我的另一套课程（Unity进阶之InputSystem）

为什么要制作 输入控制模块
制作输入控制模块主要是 降低 输入相关代码的耦合性，
以前我们制作老输入系统相关功能，都是在 Update​ 当中进行按键检测 处理对应逻辑
但是当游戏开发中存在角色切换功能时，可能就会存在冗余代码，
所以我们将通过输入控制模块来降低代码耦合性，减少冗余代码
输入控制模块的具体实现

输入控制模块的具体实现
输入控制模块的改键功能
输入控制模块的获取输入消息

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/04/22/Unity%E5%B0%B1%E4%B8%9A%E8%B7%AF%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/UFW%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/UF%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E5%B0%8F%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/UFL8%E2%80%94%E2%80%94%E5%9C%BA%E6%99%AF%E5%88%87%E6%8D%A2%E6%A8%A1%E5%9D%97/" title="UFL8——场景切换模块">UFL8——场景切换模块</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-22T04:35:00.000Z" title="发表于 2024-04-22 12:35:00">2024-04-22</time></span></div><div class="content">UFL8——场景切换模块

前置知识点

场景切换 相关知识点 （Unity四部曲之Unity入门）
协同程序 相关知识点 （Unity四部曲之Unity基础）
委托 相关知识点（C#四部曲之C#进阶）


为什么要制作场景切换模块
在游戏开发中很多时候可能需要进行场景切换，只要存在场景切换，我们往往需要在 切换场景时 和 切换场景结束后 进行一些操作
比如：

切换场景中
更新Loading界面进度条
切换场景后
隐藏Loading界面，动态创建场景中关卡信息：如角色、怪物、场景物件等等

因此为了避免有太多关于切换场景的冗余代码，并且为了使用更方便
我们可以将切换场景的逻辑统一整理在一个场景切换管理器中
实现场景切换模块的主要思路


制作 SceneMgr​ 单例模式管理器
 1234public class SceneMgr : BaseManager&lt;SceneMgr&gt;&#123;    private SceneMgr() &#123; &#125;&#125;


实现同步加载场景 的公共方法
 12345678//同步切换场景的方法public void L ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/04/21/Unity%E5%B0%B1%E4%B8%9A%E8%B7%AF%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/UFW%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/UF%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E5%B0%8F%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/UFL7%E2%80%94%E2%80%94UI%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/UFL7%E2%80%94%E2%80%94UI%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%87%BD%E6%95%B0/" title="UFL7——UI管理器的自定义事件添加函数">UFL7——UI管理器的自定义事件添加函数</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-21T14:34:22.000Z" title="发表于 2024-04-21 22:34:22">2024-04-21</time></span></div><div class="content">UFL7——UI管理器的自定义事件添加函数

前置知识点：UGUI中 EventTrigger​ 相关知识点（UI四部曲之UGUI 中）

为什么要进行 自定义事件添加函数 优化
我们在制作UI功能时，经常会有这样的需求:

为一些不带默认事件的控件添加自定义事件，比如 Image​、Text​ 这些基础组件，想为他们添加点击、单击、拖拽等事件监听
为一些带默认事件的控件添加自定义事件，比如为 Button​ 按钮添加鼠标进入、鼠标移除等事件监听

等等
1234567891011121314151617EventTrigger eventtrigger = GetControl&lt;Button&gt;(&quot;btnStart&quot;).gameObject.AddComponent&lt;EventTrigger&gt;();//鼠标抬起EventTrigger.Entry entry = new EventTrigger.Entry();entry.eventID = EventTriggerType.PointerUp;entry.callback.AddListe ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/04/21/Unity%E5%B0%B1%E4%B8%9A%E8%B7%AF%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/UFW%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/UF%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E5%B0%8F%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/UFL7%E2%80%94%E2%80%94UI%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/UFL8%E2%80%94%E2%80%94UI%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E9%9A%90%E8%97%8F%E9%9D%A2%E6%9D%BF%E5%8F%AF%E9%80%89%E9%94%80%E6%AF%81%E4%BC%98%E5%8C%96/" title="UFL8——UI管理器的隐藏面板可选销毁优化">UFL8——UI管理器的隐藏面板可选销毁优化</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-21T14:16:48.000Z" title="发表于 2024-04-21 22:16:48">2024-04-21</time></span></div><div class="content">UFL8——UI管理器的隐藏面板可选销毁优化
为什么要进行 隐藏面板可选销毁 优化
我们目前隐藏面板时，会直接将面板销毁，下次创建时再重新创建

优点：当存在内存压力时，直接销毁面板后，当内存不足时会触发GC，不会因为存在没有使用的面板引用而造成内存崩溃
缺点：会产生内存垃圾加快GC的触发，频繁的销毁创建会增加性能消耗

也就是说我们不能直接将面板隐藏改成不销毁，而应该改为可以让我们自己控制最好
我们可以根据项目的实际情况 选择性的使用失活或销毁
隐藏面板可选销毁实现
主要制作思路
无需使用缓存池，因为缓存池主要是提供给非唯一对象使用的，UI面板大部分情况下是唯一的，因此我们直接在UI管理器中修改逻辑即可
主要实现内容

隐藏面板时，可以选择销毁还是失活
显示面板时，如果存在直接激活，如果不存在再重新创建

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/04/20/Unity%E5%B0%B1%E4%B8%9A%E8%B7%AF%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/UFW%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/UF%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E5%B0%8F%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/UFL7%E2%80%94%E2%80%94UI%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/UFL7-3%E2%80%94%E2%80%94UI%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/" title="UFL7-3——UI管理器的异步加载优化">UFL7-3——UI管理器的异步加载优化</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-20T14:41:42.000Z" title="发表于 2024-04-20 22:41:42">2024-04-20</time></span></div><div class="content">UFL7-3——UI管理器的异步加载优化
为什么要进行异步加载优化
我们之前制作UI管理器时，加载资源时是在测试模式下，始终使用的是编辑器同步加载模式
若真正使用异步加载时，可能会存在报错风险
举例重现问题：


构建AB包
​​


采用异步加载方式加载AB包中的UI面板资源
将ABResManager​的isDebug​设置为false​，使得加载会选择AB包加载
 123456789101112131415161718192021222324252627282930using UnityEngine;using UnityEngine.Events;/// &lt;summary&gt;/// 用于进行加载AB相关资源的整合，在开发中可以通过EditorResManager去加载对应资源去进行测试/// &lt;/summary&gt;public class ABResManager : BaseManager&lt;ABResManager&gt;&#123;    private bool isDebug = false;    private ABResManager() ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/04/19/Unity%E5%B0%B1%E4%B8%9A%E8%B7%AF%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/UFW%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/UF%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E5%B0%8F%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/UFL7%E2%80%94%E2%80%94UI%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/UFL7-2%E2%80%94%E2%80%94UI%E7%AE%A1%E7%90%86%E5%99%A8/" title="UFL7-2——UI管理器">UFL7-2——UI管理器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-19T14:18:39.000Z" title="发表于 2024-04-19 22:18:39">2024-04-19</time></span></div><div class="content">UFL7-2——UI管理器
制作UI管理器的目的
方便管理所有UI面板，控制UI面板的显示隐藏，提供公共API供外部使用，比如：

显示面板
隐藏面板
获取面板
添加自定义事件

等等
UI管理器层级规划
主要思路：


UI面板在任何场景都会显示，因此Canvas​和EventSystem​对象应该过场景不移除，并且保证唯一性和动态创建


UI管理器 为 不继承MonoBehaviour的单例模式
 1234public class UIManager : BaseManager&lt;UIManager&gt;&#123;    private UIManager() &#123; &#125;&#125;


在构造函数中动态创建设置好的 Canvas​ 和 EventSystem​ 预设体(如果使用了UI摄像机，也需要单独处理摄像机预设体)
先在场景上创建 Canvas​ 和 EventSystem​ 以及 UI摄像机 预设体
​​
然后，在UI管理器的构造函数内动态创建这三个预设体（方便在切换场景的情况下使用）
 123456789101112131415161718192 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/04/19/Unity%E5%B0%B1%E4%B8%9A%E8%B7%AF%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/UFW%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/UF%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E5%B0%8F%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/UFL7%E2%80%94%E2%80%94UI%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/UFL7-1%E2%80%94%E2%80%94UI%E9%9D%A2%E6%9D%BF%E5%9F%BA%E7%B1%BB/" title="UFL7-1——UI面板基类">UFL7-1——UI面板基类</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-19T12:51:08.000Z" title="发表于 2024-04-19 20:51:08">2024-04-19</time></span></div><div class="content">UFL7-1——UI面板基类

前置知识点

里氏替换原则
​Dictionary​ 相关知识点（C#四部曲之C#进阶中）
委托 闭包 相关知识点（C#四部曲之C#进阶中）
​GetComponentsInChildren​（Unity四部曲之Unity入门中）


实现UI面板基类
主要实现思路：
在基类中完成声明组件、查找组件、监听组件相关功能
让子类可以直接处理事件逻辑，获取指定控件
主要实现内容：


通用的查找组件功能
我们可以使用GetComponentsInChildren​方法，来查找面板下所有的UI控件，将其添加到Dictionary&lt;string, UIBehaviour&gt;​字典内统一管理
注意，往往面板上会存在一般不会使用的同名的默认名控件，如Text (TMP)​，Image​等等
因此我们声明一个列表，记录各个控件的默认名，当获取到控件和默认名一致时，就跳过该控件
还有一种情况是，一个UI对象上挂载了多个不同的控件脚本，对于这种情况，我们可以调整控件查找的先后顺序，越重要的越先找
重要的控件就会先被记录，而后面即使找到了同一UI对象上的另外一个控件 ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/14/#content-inner"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/#content-inner">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/#content-inner">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/84/#content-inner">84</a><a class="extend next" rel="next" href="/page/16/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">文KRIFE齐</div><div class="author-info__description">目前正处于搭建测试环节</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">834</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/01/hello-world/" title="欢迎来到文KRIFE齐的博客！">欢迎来到文KRIFE齐的博客！</a><time datetime="2024-07-01T11:46:20.391Z" title="发表于 2024-07-01 19:46:20">2024-07-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/25/Unity%E5%B0%B1%E4%B8%9A%E8%B7%AF%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/US%E2%80%94%E2%80%94Unity%20Shader%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/US3%E2%80%94%E2%80%94Shader%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/US3S1%E2%80%94%E2%80%94Shader%E5%85%A5%E9%97%A8-%E5%85%89%E7%85%A7%E6%95%88%E6%9E%9C/US3S1L5%E2%80%94%E2%80%94Phong%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/" title="US3S1L5——Phong光照模型">US3S1L5——Phong光照模型</a><time datetime="2024-06-25T14:33:57.000Z" title="发表于 2024-06-25 22:33:57">2024-06-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/25/Unity%E5%B0%B1%E4%B8%9A%E8%B7%AF%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/US%E2%80%94%E2%80%94Unity%20Shader%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/US3%E2%80%94%E2%80%94Shader%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/US3S1%E2%80%94%E2%80%94Shader%E5%85%A5%E9%97%A8-%E5%85%89%E7%85%A7%E6%95%88%E6%9E%9C/US3S1L4%E2%80%94%E2%80%94Phong%E5%BC%8F%E9%AB%98%E5%85%89%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/US3S1L4-2%E2%80%94%E2%80%94Phong%E5%BC%8F%E9%AB%98%E5%85%89%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%80%90%E7%89%87%E5%85%83%E5%85%89%E7%85%A7/" title="US3S1L4-2——Phong式高光反射模型的逐片元光照">US3S1L4-2——Phong式高光反射模型的逐片元光照</a><time datetime="2024-06-25T13:16:37.000Z" title="发表于 2024-06-25 21:16:37">2024-06-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/25/Unity%E5%B0%B1%E4%B8%9A%E8%B7%AF%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/US%E2%80%94%E2%80%94Unity%20Shader%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/US3%E2%80%94%E2%80%94Shader%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/US3S1%E2%80%94%E2%80%94Shader%E5%85%A5%E9%97%A8-%E5%85%89%E7%85%A7%E6%95%88%E6%9E%9C/US3S1L4%E2%80%94%E2%80%94Phong%E5%BC%8F%E9%AB%98%E5%85%89%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/US3S1L4-1%E2%80%94%E2%80%94Phong%E5%BC%8F%E9%AB%98%E5%85%89%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%80%90%E9%A1%B6%E7%82%B9%E5%85%89%E7%85%A7/" title="US3S1L4-1——Phong式高光反射模型的逐顶点光照">US3S1L4-1——Phong式高光反射模型的逐顶点光照</a><time datetime="2024-06-25T13:16:05.000Z" title="发表于 2024-06-25 21:16:05">2024-06-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/25/Unity%E5%B0%B1%E4%B8%9A%E8%B7%AF%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/US%E2%80%94%E2%80%94Unity%20Shader%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/US3%E2%80%94%E2%80%94Shader%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/US3S1%E2%80%94%E2%80%94Shader%E5%85%A5%E9%97%A8-%E5%85%89%E7%85%A7%E6%95%88%E6%9E%9C/US3S1L4%E2%80%94%E2%80%94Phong%E5%BC%8F%E9%AB%98%E5%85%89%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/" title="US3S1L4——Phong式高光反射模型">US3S1L4——Phong式高光反射模型</a><time datetime="2024-06-25T10:14:12.000Z" title="发表于 2024-06-25 18:14:12">2024-06-25</time></div></div></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><span class="card-archive-list-count">51</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><span class="card-archive-list-count">56</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><span class="card-archive-list-count">127</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><span class="card-archive-list-count">135</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><span class="card-archive-list-count">62</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><span class="card-archive-list-count">31</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><span class="card-archive-list-count">2</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">834</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2024-07-01T14:20:11.890Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 文KRIFE齐</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>